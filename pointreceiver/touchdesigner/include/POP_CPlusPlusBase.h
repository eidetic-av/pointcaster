/* Shared Use License: This file is owned by Derivative Inc. (Derivative)
* and can only be used, and/or modified for use, in conjunction with
* Derivative's TouchDesigner software, and only if you are a licensee who has
* accepted Derivative's TouchDesigner license or assignment agreement
* (which also govern the use of this file). You may share or redistribute
* a modified version of this file provided the following conditions are met:
*
* 1. The shared file or redistribution must retain the information set out
* above and this list of conditions.
* 2. Derivative's name (Derivative Inc.) or its trademarks may not be used
* to endorse or promote products derived from this file without specific
* prior written permission from Derivative.
*/

/*
* Produced by:
*
* 				Derivative Inc
*				401 Richmond Street West, Unit 386
*				Toronto, Ontario
*				Canada   M5V 3A8
*				416-591-3555
*
* NAME:				POP_CPlusPlusBase.h
*
*
*	Do not edit this file directly!
*	Make a subclass of POP_CPlusPlusBase instead, and add your own
*	data/functions.

*	Derivative Developers:: Make sure the virtual function order
*	stays the same, otherwise changes won't be backwards compatible
*/
#pragma once

#include <assert.h>
#include "CPlusPlus_Common.h"

class POP_CPlusPlus;

namespace TD
{
class POP_CPlusPlusBase;

#pragma pack(push, 8)

// Define for the current API version that this sample code is made for.
// To upgrade to a newer version, replace the files
// POP_CPlusPlusBase.h
// CPlusPlus_Common.h
// from the samples folder in a newer TouchDesigner installation.
// You may need to upgrade your plugin code in that case, to match
// the new API requirements
const int POPCPlusPlusAPIVersion = 1 | (OP_CommonAPIVersion << 16);

class POP_PluginInfo
{
private:
	// Set it by calling setAPIVersion()
	int32_t			apiVersion = 0;
public:

	// Returns false if the API version is not supported
	[[nodiscard]]
	int32_t
	getAPIVersion() const
	{
		return apiVersion;
	}

	// Should be called with a value of POPCPlusPlusAPIVersion
	[[nodiscard]]
	bool
	setAPIVersion(int32_t version)
	{
		apiVersion = version;

		if (!isAPIVersionSupported(version))
			return false;

		return true;
	}
	[[nodiscard]]
	bool
	isAPIVersionSupported(int32_t version)
	{
		return checkAPIVersionSupported(version, MinAPIVersion, MaxAPIVersion);
	}
	// Information used to describe this plugin as a custom OP.
	OP_CustomOPInfo	customOPInfo;

	int32_t			reserved[198] = {};

	static constexpr bool checkPrivateOffsets();

private:
	// Will be set by the caller of FillPOPPluginInfo()
	const int32_t	MinAPIVersion = 0;
	const int32_t	MaxAPIVersion = 0;
	friend class ::POP_CPlusPlus;
};

constexpr bool
POP_PluginInfo::checkPrivateOffsets()
{
	return offsetof(POP_PluginInfo, apiVersion) == 0 &&
		offsetof(POP_PluginInfo, MinAPIVersion) == 8 + sizeof(customOPInfo) + 198 * 4 &&
		offsetof(POP_PluginInfo, MaxAPIVersion) == 8 + sizeof(customOPInfo) + 198 * 4 + 4;
}

// This class is passed as the OP_Context in the OP_NodeInfo. It remains valid for the life
// of the node.
class POP_Context : public OP_Context
{
protected:
	virtual ~POP_Context() {}

public:
	// Creates a POP_Buffer you can fill with data from the CPU or CUDA. Held in a OP_SmartRef.
	// This function is thread-safe if POP_BufferInfo.location = POP_BufferLocation::CPU.
	// In that case it can be called at any time in any thread, including from multiple threads at the same time.
	//
	// If POP_BufferInfo.location = POP_BufferLocation::CUDA, then this must only be called from the main thread.
	// Note that when requesting CUDA memory, it must be done before beginCUDAOperations() is called.
	//
	// You become owner of the POP_Buffer, and must give it back to the node via a call in POP_Output during execute()
	// or call release() on it yourself if you don't need it anymore.
	virtual OP_SmartRef<POP_Buffer> createBuffer(const POP_BufferInfo& info, void* reserved) = 0;

	// Returns the CUDA device index the process is currently using.
	virtual int			getCUDADeviceIndex(void* reserved) = 0;

protected:
	virtual void		reserved0() = 0;
	virtual void		reserved1() = 0;
	virtual void		reserved2() = 0;
	virtual void		reserved3() = 0;
	virtual void		reserved4() = 0;
	virtual void		reserved5() = 0;
	virtual void		reserved6() = 0;
	virtual void		reserved7() = 0;
	virtual void		reserved8() = 0;
	virtual void		reserved9() = 0;

	int32_t				reserved[200] = {};
};

class POP_GeneralInfo
{
public:
	// Set this to true if you want the SOP to cook every frame, even
	// if none of it's inputs/parameters are changing.
	// This is generally useful for cases where the node is outputting to
	// something external to TouchDesigner, such as a network socket or device.
	// It ensures the node cooks every if nothing inside the network is using/viewing
	// the output of this node.
	// Important:
	// If the node may not be viewed/used by other nodes in the file,
	// such as a TCP network output node that isn't viewed in perform mode,
	// you should set cookOnStart = true in OP_CustomOPInfo.
	// That will ensure cooking is kick-started for this node.
	// Note that this fix only works for Custom Operators, not
	// cases where the .dll is loaded into CPlusPlus SOP.
	// DEFAULT: false
	bool cookEveryFrame;

	// Set this to true if you want the SOP to cook every frame, but only
	// if someone asks for it to cook. So if nobody is using the output from
	// the SOP, it won't cook. This is difereent from 'cookEveryFrame'
	// since that will cause it to cook every frame no matter what.
	// Defaults to false.
	// DEFAULT: false
	bool	cookEveryFrameIfAsked;

private:
	int32_t		reserved[20] = {};
};

class POP_SetBufferInfo
{
public:
	// If the source buffer has been filled via CUDA, set this to the cudaStream_t that is doing the
	// CUDA operations.
	cudaStream_t	stream = 0;
	
private:
	int32_t			reserved[30] = {};
};

class POP_Output
{
public:
	POP_Output()
	{
	}

	virtual ~POP_Output()
	{
	}

	// Assign/overwrite an attribue buffer. The caller can no longer use the POP_Buffer after calling this.
	virtual void	setAttribute(OP_SmartRef<POP_Buffer>* buf, const POP_AttributeInfo& info, const POP_SetBufferInfo& sinfo, void* reserved) = 0;
	virtual void	setIndexBuffer(OP_SmartRef<POP_Buffer>* buf, const POP_IndexBufferInfo& info,
									const POP_SetBufferInfo& sinfo, void* reserved) = 0;
	// Assign the extra Info Buffers that POPs need to function. Not all buffers in POP_InfoBuffer need to be set
	// to something, in cases where that info is not needed.
	virtual void	setInfoBuffers(POP_InfoBuffers* infoBuffers, const POP_SetBufferInfo& sinfo, void* reserved) = 0;

private:

	int32_t reserved[20] = {};
};

/*** DO NOT EDIT THIS CLASS, MAKE A SUBCLASS OF IT INSTEAD ***/
class POP_CPlusPlusBase
{

protected:

	POP_CPlusPlusBase()
	{
	}

public:

	virtual
	~POP_CPlusPlusBase()
	{
	}

	// BEGIN PUBLIC INTERFACE

	// Some general settings can be assigned here (if you ovierride it)
	// The OP_Inputs* provides the access to the custom parameters
	// before the call to the execute().
	virtual void
	getGeneralInfo(POP_GeneralInfo*, const OP_Inputs*, void* reserved1)
	{
	}

	virtual void	execute(POP_Output*, const OP_Inputs*, void* reserved1) = 0;

	// Override these methods if you want to output values to the Info CHOP/DAT
	// returning 0 means you dont plan to output any Info CHOP channels
	virtual int32_t
	getNumInfoCHOPChans(void *reserved1)
	{
		return 0;
	}

	// Specify the name and value for CHOP 'index',
	// by assigning something to 'name' and 'value' members of the
	// OP_InfoCHOPChan class pointer that is passed (it points
	// to a valid instance of the class already.
	// the 'name' pointer will initially point to nullptr
	// you must allocate memory or assign a constant string
	// to it.
	virtual void
	getInfoCHOPChan(int32_t index, OP_InfoCHOPChan* chan, void *reserved1)
	{
	}


	// Return false if you arn't returning data for an Info DAT
	// Return true if you are.
	// Set the members of the CHOP_InfoDATSize class to specify
	// the dimensions of the Info DAT
	virtual bool
	getInfoDATSize(OP_InfoDATSize* infoSize, void* reserved1)
	{
		return false;
	}


	// You are asked to assign values to the Info DAT 1 row or column at a time
	// The 'byColumn' variable in 'getInfoDATSize' is how you specify
	// if it is by column or by row.
	// 'index' is the row/column index
	// 'nEntries' is the number of entries in the row/column
	// Strings should be UTF-8 encoded.
	virtual void
	getInfoDATEntries(int32_t index, int32_t nEntries, 
						OP_InfoDATEntries* entries, void* reserved1)
	{
	}


	// You can use this function to put the node into a warning state
	// with the returned string as the message.
	virtual void
	getWarningString(OP_String *warning, void *reserved1)
	{
	}

	// You can use this function to put the node into a error state
	// with the returned string as the message.
	virtual void
	getErrorString(OP_String *error, void *reserved1)
	{
	}

	// Use this function to return some text that will show up in the
	// info popup (when you middle click on a node)
	virtual void
	getInfoPopupString(OP_String *info, void *reserved1)
	{
	}


	// Override these methods if you want to define specfic parameters
	virtual void
	setupParameters(OP_ParameterManager* manager, void* reserved1)
	{
	}


	// This is called whenever a pulse parameter is pressed
	virtual void
	pulsePressed(const char* name, void* reserved1)
	{
	}

	// This is called whenever a dynamic menu type custom parameter needs to have it's content's
	// updated. It may happen often, so this could should be efficient.
	virtual void
	buildDynamicMenu(const OP_Inputs* inputs, OP_BuildDynamicMenuInfo* info, void* reserved1)
	{
	}

	// END PUBLIC INTERFACE


private:

	// Reserved for future features
	virtual int32_t	reservedFunc6() { return 0; }
	virtual int32_t	reservedFunc7() { return 0; }
	virtual int32_t	reservedFunc8() { return 0; }
	virtual int32_t	reservedFunc9() { return 0; }
	virtual int32_t	reservedFunc10() { return 0; }
	virtual int32_t	reservedFunc11() { return 0; }
	virtual int32_t	reservedFunc12() { return 0; }
	virtual int32_t	reservedFunc13() { return 0; }
	virtual int32_t	reservedFunc14() { return 0; }
	virtual int32_t	reservedFunc15() { return 0; }
	virtual int32_t	reservedFunc16() { return 0; }
	virtual int32_t	reservedFunc17() { return 0; }
	virtual int32_t	reservedFunc18() { return 0; }
	virtual int32_t	reservedFunc19() { return 0; }
	virtual int32_t	reservedFunc20() { return 0; }

	int32_t			reserved[400] = {};

};

#pragma pack(pop)

#ifndef __CUDACC__
static_assert(POP_PluginInfo::checkPrivateOffsets(), "Incorrect Alignment");
static_assert(offsetof(POP_PluginInfo, customOPInfo) == 8, "Incorrect Alignment");
static_assert(sizeof(POP_PluginInfo) == 1264, "Incorrect Size");

static_assert(offsetof(POP_GeneralInfo, cookEveryFrame) == 0, "Incorrect Alignment");
static_assert(offsetof(POP_GeneralInfo, cookEveryFrameIfAsked) == 1, "Incorrect Alignment");
//static_assert(sizeof(POP_GeneralInfo) == 80, "POP_GeneralInfo: Incorrect Size");
#endif // CUDACC

};	// namespace TD

